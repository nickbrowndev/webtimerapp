<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visual Pixel Timer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }
        
        body.fullscreen-active {
            background: #111827;
            padding: 0;
        }

        .container {
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            padding: 40px;
            max-width: 80vw;
            width: 100%;
        }
        
        .container.fullscreen-mode {
            background: #111827;
            box-shadow: none;
            border-radius: 0;
            max-width: 100%;
        }
        
        .grid-container {
            background: #f9fafb;
            padding: 2px;
            margin-bottom: 30px;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #pixelCanvas {
            display: block;
            max-width: 100%;
            height: auto;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }
        
        .fullscreen-mode .grid-container {
            width: 100vw;
            height: 100vh;
            height: 100dvh;
            margin: 0;
            border-radius: 0;
            padding: 0;
            background: #111827;
        }
        
        .fullscreen-mode #pixelCanvas {
            max-width: 100vw;
            max-height: 100vh;
            max-height: 100dvh;
            width: auto;
            height: auto;
        }

        .time-display {
            text-align: center;
            margin-bottom: 20px;
        }

        .time-value {
            font-size: 2em;
            font-weight: bold;
            color: #1f2937;
            font-family: 'Courier New', monospace;
            margin-bottom: 5px;
        }

        .progress-text {
            color: #6b7280;
            font-size: 0.85em;
        }

        .control-group {
            margin-bottom: 25px;
        }

        .control-group label {
            display: block;
            font-weight: 600;
            color: #374151;
            margin-bottom: 10px;
            font-size: 0.9em;
        }

        input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 5px;
            background: #d1d5db;
            outline: none;
            cursor: pointer;
        }

        input[type="range"]:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .color-palette {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 4px;
            width: 100%;
        }

        .color-swatch {
            width: 100%;
            aspect-ratio: 1;
            border: 2px solid transparent;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            min-width: 0;
        }

        .color-swatch:hover {
            transform: scale(1.1);
            z-index: 1;
        }

        .color-swatch.selected {
            border-color: #3b82f6;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.5);
            transform: scale(1.1);
            z-index: 2;
        }

        .color-swatch:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        button {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.9em;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .duration-presets {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
        }

        .preset-btn {
            background: #e5e7eb;
            color: #374151;
            flex: 1;
        }

        .preset-btn:hover:not(:disabled) {
            background: #d1d5db;
        }

        .control-buttons {
            display: flex;
            justify-content: center;
            gap: 12px;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }

        .btn-start {
            background: #10b981;
            color: white;
        }

        .btn-start:hover:not(:disabled) {
            background: #059669;
        }

        .btn-pause {
            background: #f59e0b;
            color: white;
        }

        .btn-pause:hover:not(:disabled) {
            background: #d97706;
        }

        .btn-reset {
            background: #6b7280;
            color: white;
        }

        .btn-reset:hover:not(:disabled) {
            background: #4b5563;
        }

        .btn-fullscreen {
            background: #3b82f6;
            color: white;
        }

        .btn-fullscreen:hover:not(:disabled) {
            background: #2563eb;
        }

        .fullscreen-mode {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            height: 100dvh;
            background: #111827;
            z-index: 9999;
            padding: 0;
            border-radius: 0;
        }

        .exit-fullscreen {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255,255,255,0.2);
            color: white;
            padding: 12px;
            border-radius: 8px;
            z-index: 10000;
        }

        .exit-fullscreen:hover {
            background: rgba(255,255,255,0.3);
        }

        .enter-fullscreen {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.1);
            color: #374151;
            padding: 12px;
            border-radius: 8px;
            z-index: 100;
        }

        .enter-fullscreen:hover {
            background: rgba(0,0,0,0.15);
        }

        .hidden {
            display: none !important;
        }

        .settings-section {
            border-top: 1px solid #e5e7eb;
            padding-top: 20px;
            margin-top: 20px;
        }

        .settings-toggle {
            width: 100%;
            justify-content: space-between;
            background: #f3f4f6;
            color: #374151;
            margin-bottom: 15px;
        }

        .settings-toggle:hover {
            background: #e5e7eb;
        }

        .toggle-icon {
            transition: transform 0.3s;
            font-size: 1.2em;
        }

        .toggle-icon.rotated {
            transform: rotate(180deg);
        }

        .collapsible-content {
            max-height: 1000px;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }

        .collapsible-content.collapsed {
            max-height: 0;
        }

        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            .time-value {
                font-size: 1.5em;
            }
            
            button {
                padding: 10px 16px;
                font-size: 0.85em;
            }
        }
    </style>
</head>
<body>
    <div class="container" id="mainContainer">
        
        <div class="grid-container" id="gridContainer">
            <canvas id="pixelCanvas"></canvas>
            <button class="enter-fullscreen" id="enterFullscreen">⛶</button>
        </div>

        <div id="controls">
            <div class="time-display">
                <div class="time-value" id="timeDisplay">0:00</div>
                <div class="progress-text" id="progressText">0% complete</div>
            </div>

            <div class="control-buttons">
                <button class="btn-start" id="startBtn">▶ Start</button>
                <button class="btn-pause hidden" id="pauseBtn">⏸ Pause</button>
                <button class="btn-reset" id="resetBtn">↻ Reset</button>
                <button class="btn-fullscreen" id="fullscreenBtn">⛶ Fullscreen</button>
            </div>

            <div class="duration-presets">
                <button class="preset-btn" data-time="60000">1 min</button>
                <button class="preset-btn" data-time="300000">5 min</button>
                <button class="preset-btn" data-time="600000">10 min</button>
                <button class="preset-btn" data-time="900000">15 min</button>
                <button class="preset-btn" data-time="1200000">20 min</button>
                <button class="preset-btn" data-time="1800000">30 min</button>
            </div>

            <div class="settings-section">
                <button class="settings-toggle" id="settingsToggle">
                    <span>⚙ Settings</span>
                    <span class="toggle-icon rotated" id="toggleIcon">▼</span>
                </button>

                <div class="collapsible-content" id="collapsibleSettings">
                    <div class="control-group">
                        <label for="durationSlider">
                            Duration: <span id="durationLabel">5 minutes</span>
                        </label>
                        <input type="range" id="durationSlider" min="1" max="3600" value="300" step="1">
                    </div>

                    <div class="control-group">
                        <label for="gridSizeSlider">
                            Pixel Size: <span id="gridSizeLabel">Loading...</span>
                        </label>
                        <input type="range" id="gridSizeSlider" min="0" max="7" value="3" step="1">
                    </div>

                    <div class="control-group">
                        <label>Start Color</label>
                        <div class="color-palette" id="startColorPalette"></div>
                    </div>

                    <div class="control-group">
                        <label>End Color</label>
                        <div class="color-palette" id="endColorPalette"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ============================================================================
        // CONFIGURATION & CONSTANTS
        // ============================================================================
        
        const CONFIG = {
            MAX_PIXELS: 250000,
            PIXEL_SIZES: [2, 4, 8, 12, 16, 24, 32, 48],
            DEFAULT_DURATION: 300000, // 5 minutes
            DEFAULT_PIXEL_SIZE: 12,
            DEFAULT_START_COLOR: '#ffffff',
            DEFAULT_END_COLOR: '#000000',
            FLASH_DURATION: 2000,
            FULLSCREEN_STYLES: {
                ACTIVE: {
                    padding: '0',
                    background: '#111827',
                    boxShadow: 'none'
                },
                INACTIVE: {
                    padding: '20px',
                    background: '#f9fafb',
                    boxShadow: 'inset 0 2px 4px rgba(0,0,0,0.1)'
                }
            }
        };

        const COLOR_PALETTE = [
            { name: 'White', value: '#ffffff' },
            { name: 'Red', value: '#ef4444' },
            { name: 'Orange', value: '#f97316' },
            { name: 'Yellow', value: '#eab308' },
            { name: 'Lime', value: '#84cc16' },
            { name: 'Green', value: '#22c55e' },
            { name: 'Cyan', value: '#06b6d4' },
            { name: 'Blue', value: '#3b82f6' },
            { name: 'Purple', value: '#a855f7' },
            { name: 'Pink', value: '#ec4899' },
            
            { name: 'Light Gray', value: '#d1d5db' },
            { name: 'Rose', value: '#fb7185' },
            { name: 'Peach', value: '#fdba74' },
            { name: 'Sand', value: '#fde047' },
            { name: 'Light Lime', value: '#bef264' },
            { name: 'Mint', value: '#86efac' },
            { name: 'Sky', value: '#7dd3fc' },
            { name: 'Light Blue', value: '#93c5fd' },
            { name: 'Lavender', value: '#c4b5fd' },
            { name: 'Light Pink', value: '#f9a8d4' },
            
            { name: 'Black', value: '#000000' },
            { name: 'Dark Red', value: '#991b1b' },
            { name: 'Brown', value: '#9a3412' },
            { name: 'Olive', value: '#854d0e' },
            { name: 'Dark Lime', value: '#3f6212' },
            { name: 'Dark Green', value: '#166534' },
            { name: 'Teal', value: '#115e59' },
            { name: 'Navy', value: '#1e3a8a' },
            { name: 'Dark Purple', value: '#6b21a8' },
            { name: 'Magenta', value: '#9f1239' }
        ];

        // ============================================================================
        // DOM ELEMENTS
        // ============================================================================
        
        const elements = {
            canvas: document.getElementById('pixelCanvas'),
            ctx: document.getElementById('pixelCanvas').getContext('2d'),
            timeDisplay: document.getElementById('timeDisplay'),
            progressText: document.getElementById('progressText'),
            durationSlider: document.getElementById('durationSlider'),
            durationLabel: document.getElementById('durationLabel'),
            gridSizeSlider: document.getElementById('gridSizeSlider'),
            gridSizeLabel: document.getElementById('gridSizeLabel'),
            startColorPalette: document.getElementById('startColorPalette'),
            endColorPalette: document.getElementById('endColorPalette'),
            startBtn: document.getElementById('startBtn'),
            pauseBtn: document.getElementById('pauseBtn'),
            resetBtn: document.getElementById('resetBtn'),
            fullscreenBtn: document.getElementById('fullscreenBtn'),
            gridContainer: document.getElementById('gridContainer'),
            controls: document.getElementById('controls'),
            mainContainer: document.getElementById('mainContainer'),
            settingsToggle: document.getElementById('settingsToggle'),
            toggleIcon: document.getElementById('toggleIcon'),
            collapsibleSettings: document.getElementById('collapsibleSettings'),
            enterFullscreenBtn: document.getElementById('enterFullscreen')
        };

        // ============================================================================
        // STATE
        // ============================================================================
        
        const state = {
            duration: CONFIG.DEFAULT_DURATION,
            timeLeft: CONFIG.DEFAULT_DURATION,
            startColor: CONFIG.DEFAULT_START_COLOR,
            endColor: CONFIG.DEFAULT_END_COLOR,
            pixelSize: CONFIG.DEFAULT_PIXEL_SIZE,
            gridWidth: 0,
            gridHeight: 0,
            pixelOrder: [],
            isRunning: false,
            isPaused: false,
            isFullscreen: false,
            isFlashing: false,
            flashProgress: 0,
            lastFlashTime: 0,
            wakeLock: null,
            settingsExpanded: true,
            animationFrameId: null,
            timerIntervalId: null
        };

        // ============================================================================
        // UTILITY FUNCTIONS
        // ============================================================================
        
        const utils = {
            shuffleArray(array) {
                const arr = [...array];
                for (let i = arr.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [arr[i], arr[j]] = [arr[j], arr[i]];
                }
                return arr;
            },

            hexToRgb(hex) {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : null;
            },

            interpolateColor(color1, color2, factor) {
                const c1 = this.hexToRgb(color1);
                const c2 = this.hexToRgb(color2);
                
                const r = Math.round(c1.r + factor * (c2.r - c1.r));
                const g = Math.round(c1.g + factor * (c2.g - c1.g));
                const b = Math.round(c1.b + factor * (c2.b - c1.b));
                
                return `rgb(${r},${g},${b})`;
            },

            formatTime(milliseconds) {
                const totalSeconds = Math.ceil(milliseconds / 1000);
                const minutes = Math.floor(totalSeconds / 60);
                const seconds = totalSeconds % 60;
                return `${minutes}:${seconds.toString().padStart(2, '0')}`;
            },

            formatDuration(milliseconds) {
                const totalSeconds = milliseconds / 1000;
                if (totalSeconds >= 60) {
                    const mins = Math.floor(totalSeconds / 60);
                    const secs = totalSeconds % 60;
                    return `${mins} min ${secs} sec`;
                }
                return `${totalSeconds} seconds`;
            },

            storageAvailable(type) {
                try {
                    const storage = window[type];
                    const x = "__storage_test__";
                    storage.setItem(x, x);
                    storage.removeItem(x);
                    return true;
                } catch (e) {
                    return e instanceof DOMException &&
                        e.name === "QuotaExceededError" &&
                        storage && storage.length !== 0;
                }
            }
        };

        // ============================================================================
        // FULLSCREEN API
        // ============================================================================
        
        const fullscreenAPI = {
            request() {
                const elem = document.documentElement;
                if (elem.requestFullscreen) {
                    return elem.requestFullscreen();
                } else if (elem.webkitRequestFullscreen) {
                    return elem.webkitRequestFullscreen();
                } else if (elem.msRequestFullscreen) {
                    return elem.msRequestFullscreen();
                }
                return Promise.resolve();
            },

            exit() {
                if (document.exitFullscreen) {
                    return document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    return document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) {
                    return document.msExitFullscreen();
                }
                return Promise.resolve();
            },

            isActive() {
                return !!(document.fullscreenElement || document.webkitFullscreenElement);
            },

            addChangeListener(callback) {
                document.addEventListener('fullscreenchange', callback);
                document.addEventListener('webkitfullscreenchange', callback);
            }
        };

        // ============================================================================
        // GRID & CANVAS MANAGEMENT
        // ============================================================================
        
        const grid = {
            updateFromViewport() {
                const vw = window.innerWidth;
                const vh = window.innerHeight;
                
                state.gridWidth = Math.max(1, Math.floor(vw / state.pixelSize));
                state.gridHeight = Math.max(1, Math.floor(vh / state.pixelSize));
                
                const totalPixels = state.gridWidth * state.gridHeight;
                if (totalPixels > CONFIG.MAX_PIXELS) {
                    this.adjustPixelSizeForLimit();
                }
                
                this.updateSizeLabel();
            },

            adjustPixelSizeForLimit() {
                const vw = window.innerWidth;
                const vh = window.innerHeight;
                const currentIndex = CONFIG.PIXEL_SIZES.indexOf(state.pixelSize);
                
                for (let i = currentIndex + 1; i < CONFIG.PIXEL_SIZES.length; i++) {
                    const testSize = CONFIG.PIXEL_SIZES[i];
                    const testWidth = Math.floor(vw / testSize);
                    const testHeight = Math.floor(vh / testSize);
                    const testTotal = testWidth * testHeight;
                    
                    if (testTotal <= CONFIG.MAX_PIXELS) {
                        state.pixelSize = testSize;
                        state.gridWidth = testWidth;
                        state.gridHeight = testHeight;
                        elements.gridSizeSlider.value = i;
                        break;
                    }
                }
            },

            generatePixelOrder() {
                const totalPixels = state.gridWidth * state.gridHeight;
                const indices = Array.from({ length: totalPixels }, (_, i) => i);
                state.pixelOrder = utils.shuffleArray(indices);
            },

            create() {
                elements.canvas.width = state.gridWidth;
                elements.canvas.height = state.gridHeight;
                
                this.resize();
                
                elements.ctx.fillStyle = state.startColor;
                elements.ctx.fillRect(0, 0, state.gridWidth, state.gridHeight);
                
                this.generatePixelOrder();
            },

            resize() {
                const aspectRatio = state.gridWidth / state.gridHeight;
                
                if (state.isFullscreen) {
                    const vw = window.innerWidth;
                    const vh = window.innerHeight;
                    const viewportRatio = vw / vh;
                    
                    if (aspectRatio > viewportRatio) {
                        elements.canvas.style.width = vw + 'px';
                        elements.canvas.style.height = (vw / aspectRatio) + 'px';
                    } else {
                        elements.canvas.style.height = vh + 'px';
                        elements.canvas.style.width = (vh * aspectRatio) + 'px';
                    }
                } else {
                    const containerWidth = elements.gridContainer.clientWidth - 4;
                    elements.canvas.style.width = containerWidth + 'px';
                    elements.canvas.style.height = (containerWidth / aspectRatio) + 'px';
                }
            },

            updateSizeLabel() {
                const total = state.gridWidth * state.gridHeight;
                elements.gridSizeLabel.textContent = 
                    `${state.pixelSize}x${state.pixelSize} pixels (${total.toLocaleString()} total)`;
            },

            drawPixels() {
                if (state.isFlashing) return;
                
                const total = state.gridWidth * state.gridHeight;
                const progress = 1 - (state.timeLeft / state.duration);
                const pixelsFilled = Math.floor(progress * total);
                const filledSet = new Set(state.pixelOrder.slice(0, pixelsFilled));
                
                for (let i = 0; i < total; i++) {
                    const x = i % state.gridWidth;
                    const y = Math.floor(i / state.gridWidth);
                    elements.ctx.fillStyle = filledSet.has(i) ? state.endColor : state.startColor;
                    elements.ctx.fillRect(x, y, 1, 1);
                }
            }
        };

        // ============================================================================
        // TIMER CONTROL
        // ============================================================================
        
        const timer = {
            start() {
                if (state.isPaused) {
                    state.isPaused = false;
                } else {
                    state.timeLeft = state.duration;
                }
                
                state.isRunning = true;
                animation.stopFlashing();
                
                ui.updateButtons('running');
                ui.disableControls(true);
                wakeLock.request();
                
                const startTime = Date.now() - (state.duration - state.timeLeft);
                
                state.timerIntervalId = setInterval(() => {
                    const elapsed = Date.now() - startTime;
                    state.timeLeft = Math.max(0, state.duration - elapsed);
                    
                    ui.updateDisplay();
                    grid.drawPixels();
                    
                    if (state.timeLeft <= 0) {
                        this.complete();
                    }
                }, 16);
            },

            pause() {
                state.isPaused = true;
                state.isRunning = false;
                clearInterval(state.timerIntervalId);
                
                ui.updateButtons('paused');
                ui.disableControls(false);
                wakeLock.release();
            },

            reset() {
                state.isRunning = false;
                state.isPaused = false;
                state.timeLeft = state.duration;
                clearInterval(state.timerIntervalId);
                
                animation.stopFlashing();
                grid.create();
                ui.updateDisplay();
                ui.updateButtons('stopped');
                ui.disableControls(false);
                wakeLock.release();
            },

            complete() {
                clearInterval(state.timerIntervalId);
                state.isRunning = false;
                state.timeLeft = 0;
                
                ui.updateDisplay();
                ui.updateButtons('completed');
                ui.disableControls(false);
                wakeLock.release();
                animation.startFlashing();
            },

            setDuration(milliseconds) {
                state.duration = milliseconds;
                if (!state.isRunning) {
                    state.timeLeft = milliseconds;
                    ui.updateDisplay();
                }
                ui.updateDurationLabel();
            },

            setDurationFromPreset(milliseconds) {
                animation.stopFlashing();
                const seconds = milliseconds / 1000;
                this.setDuration(milliseconds);
                elements.durationSlider.value = seconds;
                this.start();
            }
        };

        // ============================================================================
        // ANIMATION
        // ============================================================================
        
        const animation = {
            startFlashing() {
                state.isFlashing = true;
                state.flashProgress = 0.5;
                state.lastFlashTime = performance.now();
                
                const animate = (currentTime) => {
                    if (!state.isFlashing) return;
                    
                    const deltaTime = currentTime - state.lastFlashTime;
                    state.lastFlashTime = currentTime;
                    
                    state.flashProgress += deltaTime / CONFIG.FLASH_DURATION;
                    
                    if (state.flashProgress >= 1) {
                        state.flashProgress = 0;
                    }
                    
                    const factor = state.flashProgress < 0.5 
                        ? state.flashProgress * 2
                        : 2 - (state.flashProgress * 2);
                    
                    const color = utils.interpolateColor(state.startColor, state.endColor, factor);
                    elements.ctx.fillStyle = color;
                    elements.ctx.fillRect(0, 0, state.gridWidth, state.gridHeight);
                    
                    state.animationFrameId = requestAnimationFrame(animate);
                };
                
                state.animationFrameId = requestAnimationFrame(animate);
            },

            stopFlashing() {
                state.isFlashing = false;
                if (state.animationFrameId) {
                    cancelAnimationFrame(state.animationFrameId);
                    state.animationFrameId = null;
                }
            }
        };

        // ============================================================================
        // UI UPDATES
        // ============================================================================
        
        const ui = {
            updateDisplay() {
                elements.timeDisplay.textContent = utils.formatTime(state.timeLeft);
                const progress = Math.round((1 - (state.timeLeft / state.duration)) * 100);
                elements.progressText.textContent = `${progress}% complete`;
            },

            updateDurationLabel() {
                elements.durationLabel.textContent = utils.formatDuration(state.duration);
            },

            updateButtons(status) {
                const showStart = status === 'stopped' || status === 'paused' || status === 'completed';
                const showPause = status === 'running';
                
                elements.startBtn.classList.toggle('hidden', !showStart);
                elements.pauseBtn.classList.toggle('hidden', !showPause);
            },

            disableControls(disabled) {
                elements.durationSlider.disabled = disabled;
                elements.gridSizeSlider.disabled = disabled;
                document.querySelectorAll('.color-swatch').forEach(swatch => {
                    swatch.disabled = disabled;
                });
            },

            showGridSizeError() {
                const label = elements.gridSizeLabel;
                const originalText = label.textContent;
                label.textContent = `Too many pixels! Maximum is ${CONFIG.MAX_PIXELS.toLocaleString()}. Use a larger pixel size.`;
                label.style.color = '#ef4444';
                setTimeout(() => {
                    label.textContent = originalText;
                    label.style.color = '';
                }, 2000);
            },

            applyFullscreenStyles(active) {
                const styles = active ? CONFIG.FULLSCREEN_STYLES.ACTIVE : CONFIG.FULLSCREEN_STYLES.INACTIVE;
                Object.assign(elements.gridContainer.style, styles);
            }
        };

        // ============================================================================
        // COLOR PALETTE
        // ============================================================================
        
        const colorPalette = {
            create(paletteElement, selectedColor, callback) {
                paletteElement.innerHTML = '';
                COLOR_PALETTE.forEach(color => {
                    const swatch = document.createElement('button');
                    swatch.className = 'color-swatch';
                    swatch.style.backgroundColor = color.value;
                    swatch.title = color.name;
                    swatch.dataset.color = color.value;
                    
                    if (color.value === selectedColor) {
                        swatch.classList.add('selected');
                    }
                    
                    swatch.addEventListener('click', () => {
                        if (!state.isRunning) {
                            paletteElement.querySelectorAll('.color-swatch').forEach(s => {
                                s.classList.remove('selected');
                            });
                            swatch.classList.add('selected');
                            callback(color.value);
                        }
                    });
                    
                    paletteElement.appendChild(swatch);
                });
            },

            setStartColor(color) {
                state.startColor = color;
                storage.save();
                grid.drawPixels();
            },

            setEndColor(color) {
                state.endColor = color;
                storage.save();
                grid.drawPixels();
            }
        };

        // ============================================================================
        // FULLSCREEN MANAGEMENT
        // ============================================================================
        
        const fullscreen = {
            toggle() {
                if (state.isFullscreen) {
                    this.exit();
                } else {
                    this.enter();
                }
            },

            enter() {
                fullscreenAPI.request();
                
                state.isFullscreen = true;
                document.body.classList.add('fullscreen-active');
                elements.mainContainer.classList.add('fullscreen-mode');
                elements.controls.classList.add('hidden');
                elements.enterFullscreenBtn.style.display = 'none';
                
                ui.applyFullscreenStyles(true);
                grid.create();
                ui.updateDisplay();
                
                this.createExitButton();
            },

            exit() {
                fullscreenAPI.exit();
                
                state.isFullscreen = false;
                document.body.classList.remove('fullscreen-active');
                elements.mainContainer.classList.remove('fullscreen-mode');
                elements.controls.classList.remove('hidden');
                elements.enterFullscreenBtn.style.display = 'flex';
                
                ui.applyFullscreenStyles(false);
                grid.create();
                ui.updateDisplay();
                
                this.removeExitButton();
            },

            createExitButton() {
                const exitBtn = document.createElement('button');
                exitBtn.className = 'exit-fullscreen';
                exitBtn.id = 'exitFullscreen';
                exitBtn.innerHTML = '✕';
                exitBtn.onclick = () => this.toggle();
                elements.gridContainer.appendChild(exitBtn);
            },

            removeExitButton() {
                const exitBtn = document.getElementById('exitFullscreen');
                if (exitBtn) exitBtn.remove();
            }
        };

        // ============================================================================
        // SETTINGS
        // ============================================================================
        
        const settings = {
            toggle() {
                if (state.settingsExpanded) {
                    this.collapse();
                } else {
                    this.expand();
                }
            },

            expand() {
                elements.collapsibleSettings.classList.remove('collapsed');
                elements.toggleIcon.classList.add('rotated');
                state.settingsExpanded = true;
            },

            collapse() {
                elements.collapsibleSettings.classList.add('collapsed');
                elements.toggleIcon.classList.remove('rotated');
                state.settingsExpanded = false;
            }
        };

        // ============================================================================
        // WAKE LOCK
        // ============================================================================
        
        const wakeLock = {
            async request() {
                if ('wakeLock' in navigator) {
                    try {
                        state.wakeLock = await navigator.wakeLock.request('screen');
                    } catch (err) {
                        // Wake lock request failed
                    }
                }
            },

            release() {
                if (state.wakeLock !== null) {
                    state.wakeLock.release()
                        .then(() => {
                            state.wakeLock = null;
                        })
                        .catch(() => {
                            // Wake lock release failed
                        });
                }
            }
        };

        // ============================================================================
        // STORAGE
        // ============================================================================
        
        const storage = {
            save() {
                if (utils.storageAvailable("localStorage")) {
                    localStorage.setItem("setting.duration", state.duration);
                    localStorage.setItem("setting.startColor", state.startColor);
                    localStorage.setItem("setting.endColor", state.endColor);
                    localStorage.setItem("setting.pixelSize", state.pixelSize);
                }
            },

            load() {
                if (utils.storageAvailable("localStorage")) {
                    const savedDuration = localStorage.getItem("setting.duration");
                    const savedStartColor = localStorage.getItem("setting.startColor");
                    const savedEndColor = localStorage.getItem("setting.endColor");
                    const savedPixelSize = localStorage.getItem("setting.pixelSize");
                    
                    if (savedDuration) {
                        state.duration = parseInt(savedDuration);
                        state.timeLeft = state.duration;
                    }
                    if (savedStartColor) state.startColor = savedStartColor;
                    if (savedEndColor) state.endColor = savedEndColor;
                    if (savedPixelSize) state.pixelSize = parseInt(savedPixelSize);
                    
                    settings.collapse();
                }
            }
        };

        // ============================================================================
        // EVENT HANDLERS
        // ============================================================================
        
        const eventHandlers = {
            onDurationChange(e) {
                const milliseconds = parseInt(e.target.value) * 1000;
                timer.setDuration(milliseconds);
            },

            onGridSizeChange(e) {
                const index = parseInt(e.target.value);
                const requestedPixelSize = CONFIG.PIXEL_SIZES[index];
                
                const vw = window.innerWidth;
                const vh = window.innerHeight;
                const testWidth = Math.floor(vw / requestedPixelSize);
                const testHeight = Math.floor(vh / requestedPixelSize);
                const testTotal = testWidth * testHeight;
                
                if (testTotal <= CONFIG.MAX_PIXELS) {
                    state.pixelSize = requestedPixelSize;
                    grid.updateFromViewport();
                    grid.create();
                    if (!state.isRunning) {
                        ui.updateDisplay();
                    }
                } else {
                    const currentIndex = CONFIG.PIXEL_SIZES.indexOf(state.pixelSize);
                    e.target.value = currentIndex;
                    ui.showGridSizeError();
                }
            },

            onResize() {
                if (!state.isRunning) {
                    grid.updateFromViewport();
                    grid.create();
                    ui.updateDisplay();
                } else {
                    grid.resize();
                }
            },

            onFullscreenChange() {
                if (!fullscreenAPI.isActive() && state.isFullscreen) {
                    fullscreen.exit();
                } else if (fullscreenAPI.isActive() && state.isFullscreen) {
                    grid.resize();
                }
            },

            onVisibilityChange() {
                if (state.wakeLock !== null && 
                    document.visibilityState === 'visible' && 
                    state.isRunning) {
                    wakeLock.request();
                }
            },

            onPresetClick(e) {
                e.preventDefault();
                const time = parseInt(e.target.getAttribute('data-time'));
                timer.setDurationFromPreset(time);
            }
        };

        // ============================================================================
        // INITIALIZATION
        // ============================================================================
        
        function init() {
            // Load saved state
            storage.load();
            
            // Create color palettes
            colorPalette.create(
                elements.startColorPalette, 
                state.startColor, 
                colorPalette.setStartColor
            );
            colorPalette.create(
                elements.endColorPalette, 
                state.endColor, 
                colorPalette.setEndColor
            );
            
            // Set up event listeners
            elements.startBtn.addEventListener('click', () => timer.start());
            elements.pauseBtn.addEventListener('click', () => timer.pause());
            elements.resetBtn.addEventListener('click', () => timer.reset());
            elements.fullscreenBtn.addEventListener('click', () => fullscreen.toggle());
            elements.enterFullscreenBtn.addEventListener('click', () => fullscreen.toggle());
            elements.settingsToggle.addEventListener('click', () => settings.toggle());
            
            elements.durationSlider.addEventListener('input', eventHandlers.onDurationChange);
            elements.gridSizeSlider.addEventListener('input', eventHandlers.onGridSizeChange);
            
            window.addEventListener('resize', eventHandlers.onResize);
            document.addEventListener('visibilitychange', eventHandlers.onVisibilityChange);
            fullscreenAPI.addChangeListener(eventHandlers.onFullscreenChange);
            
            document.querySelectorAll('.preset-btn').forEach(btn => {
                btn.addEventListener('click', eventHandlers.onPresetClick);
            });
            
            // Initialize grid and display
            grid.updateFromViewport();
            grid.create();
            ui.updateDisplay();
            ui.updateDurationLabel();
            grid.updateSizeLabel();
        }

        // Start the application
        init();
    </script>
</body>
</html>
